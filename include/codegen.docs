// Assuming A, B are given registers since it(8bit-computer) does not mention the register descriptor

**I** reserve A for declarations, B for computation (destructive).



 enum class expr_kind {
  TYPE,
      <>
  IDENTIFIER,
      a = 3;
      a = a + 3;
      How do i ternary-lise this?
      Here identifier is both in rhs and lhs hence
        In left: lda <scratch_address> // load in A data of mem(a)
        In right: mov B M <scratch_address> // load in B data of mem(a)
  NUM,
      3 == 3;
      a = 3;
      generate() { ternary:
      In left: ldi A <val>
      In right: ldi B <val>
 }
  INFIX,
      a + 3;
      l.expr op.str r.expr
      technically infix is totally on right>?
      In right:
          generate(l.expr)
          generate(r.expr)
          switch(op.str) {
               case "+":
                  add
               case "-":
                  sub
               case "==":
                  cmp
               default:
                  add_error("codegen unsupported operator")
          }


  CONDN,
      Delegate to infix?



  enum class stmnt_kind {
  EXPR_STMNT,
       generate(expression)
       sta mem_loc(identifier)
  IF_STMNT,
      if is not really left or right??
      generate(CONDN.expr)
      jne %donelabel
      generate(body.expr)
      jmp %donelabel
      cout << donelabel: // Assuming empty labels are supported.
  VARDEC_STMNT,
      generate(identifier)

